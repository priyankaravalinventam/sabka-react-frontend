"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findServerEntry = exports.serverEntryPlugin = void 0;
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const serverEntryImportPromise_1 = require("../shared/serverEntryImportPromise");
const serverEntryFileNameBase_1 = require("../shared/serverEntryFileNameBase");
const debugLogsBuildTime_1 = require("./debugLogsBuildTime");
const indexEntryName = 'index';
const autoImporterFilePath = require.resolve('../importServerEntry/autoImporter.js');
const serverEntryVirtualId = 'virtual:@brillout/vite-plugin-server-entry:serverEntry';
// https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
const virtualIdPrefix = '\0';
const apiVersion = 4;
/**
 * This plugin does two things:
 *  - Generates a "server entry" file at `dist/server/entry.js`.
 *  - Generates a "auto importer" file at `node_modules/@brillout/vite-plugin-server-entry/dist/importServerEntry/autoImporter.js`.
 *
 * See https://github.com/brillout/vite-plugin-server-entry#what-it-does for more information.
 */
function serverEntryPlugin(pluginConfigProvidedByLibrary) {
    const pluginName = `@brillout/vite-plugin-server-entry:${pluginConfigProvidedByLibrary.libraryName.toLowerCase()}`;
    let config;
    let serverIndexFilePath;
    let library;
    let skip;
    let injectDone = false;
    return [
        {
            name: pluginName,
            apply: 'build',
            // We need to run this plugin after other plugin instances, so that assertApiVersions() works also for libraries using older plugin versions
            enforce: 'post',
            configResolved() {
                if (skip)
                    return;
                if (!isLeaderPluginInstance(config, library)) {
                    skip = true;
                    return;
                }
                assertApiVersions(config, pluginConfigProvidedByLibrary.libraryName);
                if (!config._vitePluginServerEntry.inject) {
                    const entries = (0, utils_1.normalizeRollupInput)(config.build.rollupOptions.input);
                    (0, utils_1.assert)(entries[serverEntryFileNameBase_1.serverEntryFileNameBase] !== serverEntryVirtualId &&
                        entries[serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative] !== serverEntryVirtualId);
                    const fileNameBase = !entries[serverEntryFileNameBase_1.serverEntryFileNameBase]
                        ? serverEntryFileNameBase_1.serverEntryFileNameBase
                        : serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative;
                    (0, utils_1.assert)(!entries[fileNameBase]);
                    config.build.rollupOptions.input = (0, utils_1.injectRollupInputs)({ [fileNameBase]: serverEntryVirtualId }, config);
                }
            },
            buildStart() {
                if (skip)
                    return;
                serverIndexFilePath = config._vitePluginServerEntry.inject ? getServerIndexFilePath(config) : null;
                clearAutoImporterFile({ status: 'RESET' });
            },
            resolveId(id) {
                if (skip)
                    return;
                if (id === serverEntryVirtualId) {
                    return virtualIdPrefix + serverEntryVirtualId;
                }
            },
            load(id) {
                if (skip)
                    return;
                (0, utils_1.assert)(id !== serverEntryVirtualId);
                if (id === virtualIdPrefix + serverEntryVirtualId) {
                    const serverEntryFileContent = getServerEntryFileContent(config);
                    return serverEntryFileContent;
                }
            },
            generateBundle(_rollupOptions, bundle) {
                if (skip)
                    return;
                const isInject = config._vitePluginServerEntry.inject;
                if (isInject) {
                    (0, utils_1.assert)(injectDone);
                }
                const entry = findServerEntry(bundle);
                // Write node_modules/@brillout/vite-plugin-server-entry/dist/autoImporter.js
                const isTestCrawler = config._vitePluginServerEntry.testCrawler;
                const doNotAutoImport = isInject || (0, utils_1.isYarnPnP)() || isTestCrawler;
                if (!doNotAutoImport) {
                    (0, utils_1.assert)(!isInject && entry);
                    const entryFileName = entry.fileName;
                    writeAutoImporterFile(config, entryFileName);
                }
                else {
                    const status = isTestCrawler ? 'TEST_CRAWLER' : 'DISABLED';
                    clearAutoImporterFile({ status });
                    (0, debugLogsBuildTime_1.debugLogsBuildtime)({ disabled: true, paths: null });
                }
                if (!isInject) {
                    ;
                    ['importBuild.cjs', 'importBuild.mjs', 'importBuild.js'].forEach((fileName) => {
                        (0, utils_1.assert)(!isInject && entry);
                        const entryFileName = entry.fileName;
                        this.emitFile({
                            fileName,
                            type: 'asset',
                            source: [
                                `globalThis.${serverEntryImportPromise_1.serverEntryImportPromise} = import('./${entryFileName}');`,
                                `console.warn("[Warning] The server entry has been renamed from dist/server/importBuild.{cjs,mjs,js} to dist/server/entry.{cjs,mjs,js} â€” update your import('../path/to/dist/server/importBuild.{cjs,mjs,js}') accordingly.");`
                            ].join('\n')
                        });
                    });
                }
            },
            transform(code, id) {
                if (skip)
                    return;
                if (!config._vitePluginServerEntry.inject)
                    return;
                (0, utils_1.assert)(serverIndexFilePath);
                if (id !== serverIndexFilePath)
                    return;
                {
                    const moduleInfo = this.getModuleInfo(id);
                    (0, utils_1.assert)(moduleInfo?.isEntry);
                }
                injectDone = true;
                code = [
                    /* We don't do this, instead let Vike's CLI handle the default process.env.NODE_ENV value.
                    "process.env.NODE_ENV = 'production';", */
                    // Imports the entry of each tool, e.g. the Vike entry and the Telefunc entry.
                    `import '${serverEntryVirtualId}';`,
                    code
                ].join(''
                /* We don't insert new lines, otherwise we break the source map.
              '\n'
              */
                );
                return code;
            }
        },
        {
            name: `${pluginName}:config`,
            apply: 'build',
            // We need to run this plugin before in order to make isLeaderPluginInstance() work
            enforce: 'pre',
            configResolved(configUnresolved) {
                // Upon the server-side build (`$ vite build --ssr`), we need to override the previous `skip` value set by the client-side build (`$ vite build`).
                skip = !(0, utils_1.viteIsSSR)(configUnresolved);
                if (skip)
                    return;
                (0, utils_1.assertUsage)(typeof configUnresolved.build.ssr !== 'string', "Setting the server build entry over the Vite configuration `build.ssr` (i.e. `--ssr path/to/entry.js`) isn't supported (because of a Vite bug), see workaround at https://github.com/brillout/vite-plugin-server-entry/issues/9#issuecomment-2027641624");
                const resolved = resolveConfig(configUnresolved, pluginConfigProvidedByLibrary);
                config = resolved.config;
                library = resolved.library;
            }
        }
    ];
}
exports.serverEntryPlugin = serverEntryPlugin;
function resolveConfig(configUnresolved, pluginConfigProvidedByLibrary) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(configUnresolved));
    const pluginConfigProvidedByUser = configUnresolved.vitePluginServerEntry;
    const pluginConfigResolved = configUnresolved._vitePluginServerEntry ?? {
        libraries: [],
        apiVersion,
        testCrawler: false,
        inject: false
    };
    if (pluginConfigProvidedByLibrary.inject) {
        pluginConfigResolved.inject = true;
    }
    if (pluginConfigProvidedByUser?._testCrawler) {
        pluginConfigResolved.testCrawler = true;
    }
    // @ts-expect-error workaround for previously broken api version assertion
    pluginConfigResolved.configVersion = 1;
    const library = {
        getImporterCode: pluginConfigProvidedByLibrary.getImporterCode,
        libraryName: pluginConfigProvidedByLibrary.libraryName,
        pluginVersion: utils_1.projectInfo.projectVersion,
        apiVersion
    };
    pluginConfigResolved.libraries.push(library);
    (0, utils_1.objectAssign)(configUnresolved, {
        _vitePluginServerEntry: pluginConfigResolved
    });
    const config = configUnresolved;
    return { config, library };
}
function isLeaderPluginInstance(config, library) {
    const { libraries } = config._vitePluginServerEntry;
    const pluginVersionCurrent = utils_1.projectInfo.projectVersion;
    (0, utils_1.assert)(libraries.includes(library));
    const isNotUsingNewestPluginVersion = libraries.some((lib) => {
        // Can be undefined when set by an older @brillout/vite-plugin-dist-importer version
        if (!lib.pluginVersion)
            return false;
        return isHigherVersion(lib.pluginVersion, pluginVersionCurrent);
    });
    if (isNotUsingNewestPluginVersion)
        return false;
    const librariesUsingNewestPluginVersion = libraries.filter((lib) => lib.pluginVersion === pluginVersionCurrent);
    return librariesUsingNewestPluginVersion[0] === library;
}
function getServerEntryFileContent(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const serverEntryFileContent = [
        '// Generated by https://github.com/brillout/vite-plugin-server-entry',
        ...config._vitePluginServerEntry.libraries.map((library) => {
            // Should be true becasue of assertApiVersions()
            (0, utils_1.assert)(getLibraryApiVersion(library) === apiVersion);
            const entryCode = library.getImporterCode();
            return entryCode;
        })
    ].join('\n');
    return serverEntryFileContent;
}
function writeAutoImporterFile(config, entryFileName) {
    const { distServerPathRelative, distServerPathAbsolute } = getDistServerPathRelative(config);
    const serverEntryFilePathRelative = path_1.default.posix.join(distServerPathRelative, entryFileName);
    const serverEntryFilePathAbsolute = path_1.default.posix.join(distServerPathAbsolute, entryFileName);
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)(!(0, utils_1.isYarnPnP)());
    (0, fs_1.writeFileSync)(autoImporterFilePath, [
        "exports.status = 'SET';",
        `exports.loadServerEntry = async () => { await import(${JSON.stringify(serverEntryFilePathRelative)}); };`,
        'exports.paths = {',
        `  autoImporterFilePathOriginal: ${JSON.stringify(autoImporterFilePath)},`,
        '  autoImporterFileDirActual: (() => { try { return __dirname } catch { return null } })(),',
        `  serverEntryFilePathRelative: ${JSON.stringify(serverEntryFilePathRelative)},`,
        `  serverEntryFilePathOriginal: ${JSON.stringify(serverEntryFilePathAbsolute)},`,
        `  serverEntryFilePathResolved: () => require.resolve(${JSON.stringify(serverEntryFilePathRelative)}),`,
        '};',
        ''
    ].join('\n'));
}
function clearAutoImporterFile(autoImporter) {
    if ((0, utils_1.isYarnPnP)())
        return;
    (0, fs_1.writeFileSync)(autoImporterFilePath, [`exports.status = '${autoImporter.status}';`, ''].join('\n'));
}
/** Is `semver1` higher than `semver2`?*/
function isHigherVersion(semver1, semver2) {
    const parsed1 = parseSemver(semver1);
    const parsed2 = parseSemver(semver2);
    for (let i = 0; i <= parsed1.parts.length - 1; i++) {
        if (parsed1.parts[i] !== parsed2.parts[i]) {
            return parsed1.parts[i] > parsed2.parts[i];
        }
    }
    if (parsed1.isPreRelease !== parsed2.isPreRelease) {
        return parsed1.isPreRelease;
    }
    return false;
}
function parseSemver(semver) {
    let isPreRelease = false;
    if (semver.includes('-')) {
        isPreRelease = true;
        semver = semver.split('-')[0]; // '0.2.16-commit-89bbe89' => '0.2.16'
    }
    (0, utils_1.assert)(/^[0-9\.]+$/.test(semver));
    const partsStr = semver.split('.');
    (0, utils_1.assert)(partsStr.length === 3);
    const parts = partsStr.map((n) => parseInt(n, 10));
    return { parts, isPreRelease };
}
function getDistServerPathRelative(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)((0, utils_1.isAbsolutePath)(root));
    const importerDir = getDirname();
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let { outDir } = config.build;
    // SvelteKit doesn't set config.build.outDir to a posix path
    outDir = (0, utils_1.toPosixPath)(outDir);
    if ((0, utils_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_1.assert)(!(0, utils_1.isAbsolutePath)(outDir));
    }
    const distServerPathRelative = path_1.default.posix.join(rootRelative, outDir);
    const distServerPathAbsolute = path_1.default.posix.join(root, outDir);
    (0, debugLogsBuildTime_1.debugLogsBuildtime)({
        disabled: false,
        paths: { importerDir, root, rootRelative, outDir, distServerPathRelative, distServerPathAbsolute }
    });
    return { distServerPathRelative, distServerPathAbsolute };
}
function getDirname() {
    const dirname = (0, utils_1.toPosixPath)(__dirname + (() => '')()); // trick to avoid `@vercel/ncc` to glob import
    return dirname;
}
function assertApiVersions(config, currentLibraryName) {
    const librariesNeedingUpdate = [];
    ['vitePluginDistImporter', '_vitePluginImportBuild'].forEach((key) => {
        if (key in config) {
            const dataOld = config[key];
            dataOld.libraries.forEach((lib) => {
                (0, utils_1.assert)(lib.libraryName);
                librariesNeedingUpdate.push(lib.libraryName);
            });
        }
    });
    const pluginConfigResolved = config._vitePluginServerEntry;
    pluginConfigResolved.libraries.forEach((library) => {
        const apiVersionLib = getLibraryApiVersion(library);
        if (apiVersionLib < apiVersion) {
            librariesNeedingUpdate.push(library.libraryName);
        }
        else {
            // Should be true thanks to isLeaderPluginInstance()
            (0, utils_1.assert)(apiVersionLib === apiVersion);
        }
    });
    if (librariesNeedingUpdate.length > 0) {
        const libs = (0, utils_1.joinEnglish)(librariesNeedingUpdate, 'and');
        // We purposely use `throw new Error()` instead of `assertUsage()`, in order to not confuse the user with superfluous information
        throw new Error(`Update ${libs} to its latest version and try again: ${currentLibraryName} requires a newer version of ${libs}.`);
    }
}
function getLibraryApiVersion(library) {
    // library.apiVersion can be undefined when set by an older @brillout/vite-plugin-server-entry version
    const apiVersionLib = library.apiVersion ?? 1;
    return apiVersionLib;
}
function findServerEntry(bundle) {
    const entry = 
    // prettier-ignore
    (0, utils_1.findRollupBundleEntry)(serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative, bundle) ||
        (0, utils_1.findRollupBundleEntry)(serverEntryFileNameBase_1.serverEntryFileNameBase, bundle) ||
        (0, utils_1.findRollupBundleEntry)(indexEntryName, bundle);
    (0, utils_1.assertUsage)(entry, errMsgEntryRemoved([
        //
        serverEntryFileNameBase_1.serverEntryFileNameBase,
        serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative,
        indexEntryName
    ], Object.keys(bundle)));
    return entry;
}
exports.findServerEntry = findServerEntry;
function getServerIndexFilePath(config) {
    const entries = (0, utils_1.normalizeRollupInput)(config.build.rollupOptions.input);
    let serverEntryFilePath = entries[indexEntryName];
    if (!serverEntryFilePath) {
        const entryNames = Object.keys(entries);
        (0, utils_1.assertUsage)(false, errMsgEntryRemoved([indexEntryName], entryNames));
    }
    serverEntryFilePath = require.resolve(serverEntryFilePath);
    // Needs to be absolute, otherwise it won't match the `id` in `transform(id)`
    (0, utils_1.assert)(path_1.default.isAbsolute(serverEntryFilePath));
    serverEntryFilePath = (0, utils_1.toPosixPath)(serverEntryFilePath);
    return serverEntryFilePath;
}
function errMsgEntryRemoved(entriesMissing, entriesExisting) {
    const list = (items) => '[' + items.map((e) => `'${e}'`).join(', ') + ']';
    return [
        entriesMissing.length === 1
            ? `Cannot find build server entry '${entriesMissing[0]}'.`
            : `Cannot find build server entry, searching for:  ${list(entriesMissing)} (none of them exist, but one of these should exist).`,
        `Make sure your Vite config (or that of a Vite plugin) doesn't remove/overwrite server build entries.`,
        `(Found server entries: ${list(entriesExisting)}.)`
    ].join(' ');
}
