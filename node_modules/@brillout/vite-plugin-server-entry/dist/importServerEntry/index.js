"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importServerEntry = void 0;
const utils_1 = require("./utils");
const import_1 = require("@brillout/import");
const debugLogsRuntime_1 = require("./debugLogsRuntime");
const serverEntryImportPromise_1 = require("../shared/serverEntryImportPromise");
const serverEntryFileNameBase_1 = require("../shared/serverEntryFileNameBase");
const debug_1 = require("../shared/debug");
async function importServerEntry(outDir) {
    const autoImporter = require('./autoImporter.js');
    (0, debugLogsRuntime_1.debugLogsRuntimePre)(autoImporter);
    (0, utils_1.assertUsage)(autoImporter.status !== 'DISABLED', "As a library author, make sure your library doesn't call importServerEntry() when using `inject: true`");
    let success = false;
    let requireError;
    let isOutsideOfCwd = null;
    if (autoImporter.status === 'SET') {
        try {
            await autoImporter.loadServerEntry();
            await globalThis[serverEntryImportPromise_1.serverEntryImportPromise];
            success = true;
        }
        catch (err) {
            if (debug_1.DEBUG) {
                requireError = err;
            }
            else {
                throw err;
            }
        }
        isOutsideOfCwd = isServerEntryOutsideOfCwd(autoImporter.paths);
        if (isOutsideOfCwd) {
            success = false;
        }
    }
    else {
        // Maybe this assertion is too strict? Is it prone to race conditions?
        (0, utils_1.assert)(autoImporter.status !== 'RESET');
        (0, utils_1.assert)(
        // Yarn PnP
        autoImporter.status === 'UNSET' ||
            // User sets config.vitePluginServerEntry._testCrawler
            autoImporter.status === 'TEST_CRAWLER');
    }
    if (!success) {
        success = await crawlServerEntryFileWithNodeJs(outDir);
    }
    // We don't handle the following case:
    //  - When the user directly imports dist/server/entry.js because we assume that Vike and Telefunc don't call importServerEntry() in that case
    (0, debugLogsRuntime_1.debugLogsRuntimePost)({ success, requireError, isOutsideOfCwd, outDir });
    (0, utils_1.assertUsage)(success, 'Cannot find server entry. (Re-)build your app and try again. If you still get this error, then you may need to manually import the server entry, see https://github.com/brillout/vite-plugin-server-entry#manual-import');
}
exports.importServerEntry = importServerEntry;
// dist/server/entry.js may not belong to process.cwd() if e.g. Vike is linked => autoImporter.js can potentially be shared between multiple projects
function isServerEntryOutsideOfCwd(paths) {
    const cwd = (0, utils_1.getCwd)();
    // We cannot check edge environments. Upon edge deployment the server code is usually bundled right after `$ vite build`, so it's unlikley that the resolved serverEntryFilePath doesn't belong to cwd
    if (!cwd)
        return null;
    let serverEntryFilePath;
    try {
        serverEntryFilePath = paths.serverEntryFilePathResolved();
    }
    catch {
        // Edge environments usually(/always?) don't support require.resolve()
        //  - This code block is called for edge environments that return a dummy process.cwd(), e.g. Cloudflare Workers: process.cwd() === '/'
        return null;
    }
    if (isWebpackResolve(serverEntryFilePath))
        return null;
    serverEntryFilePath = (0, utils_1.toPosixPath)(serverEntryFilePath);
    (0, utils_1.assertPosixPath)(cwd);
    return !serverEntryFilePath.startsWith(cwd);
}
async function crawlServerEntryFileWithNodeJs(outDir) {
    const cwd = (0, utils_1.getCwd)();
    if (!cwd)
        return false;
    let path;
    let fs;
    try {
        path = await (0, import_1.import_)('path');
        fs = await (0, import_1.import_)('fs');
    }
    catch {
        return false;
    }
    const isPathAbsolute = (p) => {
        if (process.platform === 'win32') {
            return path.win32.isAbsolute(p);
        }
        else {
            return p.startsWith('/');
        }
    };
    if (outDir) {
        // Only pre-rendering has access to config.build.outDir
        (0, utils_1.assertPosixPath)(outDir);
        (0, utils_1.assert)(isPathAbsolute(outDir), outDir);
    }
    else {
        // The SSR server doesn't have access to config.build.outDir so we shoot in the dark by trying with 'dist/'
        outDir = path.posix.join(cwd, 'dist');
    }
    const serverEntryFileDir = path.posix.join(outDir, 'server');
    if (!fs.existsSync(serverEntryFileDir))
        return false;
    let filename;
    try {
        filename = __filename;
    }
    catch {
        // __filename isn't defined when this file is being bundled into an ESM bundle
        return false;
    }
    let serverEntryFilePath = null;
    const entryFileCandidates = [
        `${serverEntryFileNameBase_1.serverEntryFileNameBase}.mjs`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBase}.js`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBase}.cjs`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative}.mjs`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative}.js`,
        `${serverEntryFileNameBase_1.serverEntryFileNameBaseAlternative}.cjs`
    ];
    for (const entryFileName of entryFileCandidates) {
        const serverEntryFilePathSpeculative = path.posix.join(serverEntryFileDir, entryFileName);
        try {
            serverEntryFilePath = await (0, utils_1.requireResolve)(serverEntryFilePathSpeculative, filename);
        }
        catch { }
    }
    (0, utils_1.assertUsage)(serverEntryFilePath, `Cannot find server entry. If you use rollupOptions.output.entryFileNames then make sure to not rename the server entry file. Make sure that one of the following exists: \n${entryFileCandidates.map((e) => `  ${e}`).join('\n')}`);
    // webpack couldn't have properly resolved distImporterPath (since there is not static import statement)
    if (isWebpackResolve(serverEntryFilePath)) {
        return false;
    }
    await (0, import_1.import_)(serverEntryFilePath);
    await globalThis[serverEntryImportPromise_1.serverEntryImportPromise];
    return true;
}
function isWebpackResolve(moduleResolve) {
    return typeof moduleResolve === 'number';
}
