import "./chunk-ZS7NZCD4.js";

// node_modules/vike/dist/esm/utils/unique.js
function unique(arr) {
  return Array.from(new Set(arr));
}

// node_modules/vike/dist/esm/utils/projectInfo.js
var PROJECT_VERSION = "0.4.179";
var projectInfo = {
  projectName: "Vike",
  projectVersion: PROJECT_VERSION
};

// node_modules/vike/dist/esm/utils/getGlobalObject.js
var projectKey = `_${projectInfo.projectName.toLowerCase()}`;
function getGlobalObject(key, defaultValue) {
  const globalObjects = getGlobalObjects();
  const globalObject4 = globalObjects[key] = globalObjects[key] || defaultValue;
  return globalObject4;
}
function getGlobalObjects() {
  const globalObjects = globalThis[projectKey] = globalThis[projectKey] || {};
  return globalObjects;
}

// node_modules/vike/dist/esm/utils/assertSingleInstance.js
import pc from "@brillout/picocolors";
var globalObject = getGlobalObject("assertPackageInstances.ts", {
  instances: [],
  alreadyLogged: /* @__PURE__ */ new Set()
});
var clientNotSingleInstance = "Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";
function assertSingleInstance() {
  {
    const versions = unique(globalObject.instances);
    assertUsage(
      versions.length <= 1,
      // DO *NOT* patch vike to remove this error: because of multiple conflicting versions, you *will* eventually encounter insidious issues that hard to debug and potentially a security hazard, see for example https://github.com/vikejs/vike/issues/1108
      `vike@${pc.bold(versions[0])} and vike@${pc.bold(versions[1])} loaded but only one version should be loaded`
    );
  }
  if (globalObject.checkSingleInstance && globalObject.instances.length > 1) {
    assertWarning(false, clientNotSingleInstance, { onlyOnce: true, showStackTrace: true });
  }
}
function assertSingleInstance_onAssertModuleLoad() {
  globalObject.instances.push(projectInfo.projectVersion);
  assertSingleInstance();
}
function assertUsage(condition, errorMessage) {
  if (condition) {
    return;
  }
  const errMsg = `[vike][Wrong Usage] ${errorMessage}`;
  throw new Error(errMsg);
}
function assertWarning(condition, errorMessage, { onlyOnce, showStackTrace }) {
  if (condition) {
    return;
  }
  const msg = `[vike][Warning] ${errorMessage}`;
  if (onlyOnce) {
    const { alreadyLogged } = globalObject;
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged.has(key)) {
      return;
    } else {
      alreadyLogged.add(key);
    }
  }
  if (showStackTrace) {
    console.warn(new Error(msg));
  } else {
    console.warn(msg);
  }
}

// node_modules/vike/dist/esm/utils/isNodeJS.js
function isNodeJS() {
  if (typeof process === "undefined")
    return false;
  if (!process.cwd)
    return false;
  if (!process.versions || typeof process.versions.node === "undefined")
    return false;
  if (!process.release || process.release.name !== "node")
    return false;
  return true;
}

// node_modules/vike/dist/esm/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace(errorMessage, numberOfStackTraceLinesToRemove2) {
  const err = new Error(errorMessage);
  if (isNodeJS()) {
    err.stack = clean(err.stack, numberOfStackTraceLinesToRemove2);
  }
  return err;
}
function clean(errStack, numberOfStackTraceLinesToRemove2) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove2 && isStackTraceLine(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine(line) {
  return line.startsWith("    at ");
}
function splitByLine(str) {
  return str.split(/\r?\n/);
}

// node_modules/vike/dist/esm/utils/assert.js
import pc2 from "@brillout/picocolors";
var globalObject2 = getGlobalObject("utils/assert.ts", {
  alreadyLogged: /* @__PURE__ */ new Set(),
  // Production logger. Overwritten by loggerNotProd.ts in non-production environments.
  logger(msg, logType) {
    if (logType === "info") {
      console.log(msg);
    } else {
      console.warn(msg);
    }
  },
  showStackTraceList: /* @__PURE__ */ new WeakSet()
});
assertSingleInstance_onAssertModuleLoad();
var projectTag = `[vike]`;
var projectTagWithVersion = `[vike@${projectInfo.projectVersion}]`;
var numberOfStackTraceLinesToRemove = 2;
function assert(condition, debugInfo) {
  var _a;
  if (condition)
    return;
  const debugStr = (() => {
    if (!debugInfo) {
      return null;
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : JSON.stringify(debugInfo);
    return pc2.dim(`Debug info (for Vike maintainers; you can ignore this): ${debugInfoSerialized}`);
  })();
  const link = pc2.blue("https://github.com/vikejs/vike/issues/new");
  let errMsg = [
    `You stumbled upon a Vike bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,
    debugStr
  ].filter(Boolean).join(" ");
  errMsg = addWhitespace(errMsg);
  errMsg = addPrefixAssertType(errMsg, "Bug");
  errMsg = addPrefixProjctName(errMsg, true);
  const internalError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);
  (_a = globalObject2.onBeforeLog) == null ? void 0 : _a.call(globalObject2);
  throw internalError;
}
function assertUsage2(condition, errMsg, { showStackTrace } = {}) {
  var _a;
  if (condition)
    return;
  showStackTrace = showStackTrace || globalObject2.alwaysShowStackTrace;
  errMsg = addWhitespace(errMsg);
  errMsg = addPrefixAssertType(errMsg, "Wrong Usage");
  errMsg = addPrefixProjctName(errMsg);
  const usageError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);
  if (showStackTrace) {
    globalObject2.showStackTraceList.add(usageError);
  }
  (_a = globalObject2.onBeforeLog) == null ? void 0 : _a.call(globalObject2);
  throw usageError;
}
function assertWarning2(condition, msg, { onlyOnce, showStackTrace }) {
  var _a;
  if (condition)
    return;
  showStackTrace = showStackTrace || globalObject2.alwaysShowStackTrace;
  msg = addWhitespace(msg);
  msg = addPrefixAssertType(msg, "Warning");
  msg = addPrefixProjctName(msg);
  if (onlyOnce) {
    const { alreadyLogged } = globalObject2;
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged.has(key)) {
      return;
    } else {
      alreadyLogged.add(key);
    }
  }
  (_a = globalObject2.onBeforeLog) == null ? void 0 : _a.call(globalObject2);
  if (showStackTrace) {
    const err = createErrorWithCleanStackTrace(msg, numberOfStackTraceLinesToRemove);
    globalObject2.showStackTraceList.add(err);
    globalObject2.logger(err, "warn");
  } else {
    globalObject2.logger(msg, "warn");
  }
}
function addPrefixAssertType(msg, tag) {
  let prefix = `[${tag}]`;
  const color = tag === "Warning" ? "yellow" : "red";
  prefix = pc2.bold(pc2[color](prefix));
  return `${prefix}${msg}`;
}
function addWhitespace(msg) {
  if (msg.startsWith("[")) {
    return msg;
  } else {
    return ` ${msg}`;
  }
}
function addPrefixProjctName(msg, showProjectVersion = false) {
  const prefix = showProjectVersion ? projectTagWithVersion : projectTag;
  return `${prefix}${msg}`;
}

// node_modules/vike/dist/esm/shared/hooks/executeHook.js
var globalObject3 = getGlobalObject("utils/executeHook.ts", {
  userHookErrors: /* @__PURE__ */ new WeakMap(),
  pageContext: null
});

// node_modules/vike/dist/esm/utils/isBrowser.js
function isBrowser() {
  return typeof window !== "undefined" && typeof window.scrollY === "number";
}

// node_modules/vike/dist/esm/utils/assertRoutingType.js
import pc3 from "@brillout/picocolors";
var state = getGlobalObject("utils/assertRouterType.ts", {});
function assertClientRouting() {
  assertNoContradiction(checkIfClientRouting());
  state.isClientRouting = true;
}
function checkIfClientRouting() {
  return state.isClientRouting !== false;
}
function assertNoContradiction(noContradiction) {
  assertUsage2(isBrowser(), `${pc3.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`, { showStackTrace: true });
  assertWarning2(noContradiction, "You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.", { showStackTrace: true, onlyOnce: true });
}

// node_modules/vike/dist/esm/utils/objectAssign.js
function objectAssign(obj, objAddendum) {
  if (objAddendum) {
    Object.defineProperties(obj, Object.getOwnPropertyDescriptors(objAddendum));
  }
}

// node_modules/vike/dist/esm/utils/parseUrl.js
import pc4 from "@brillout/picocolors";
function isUriWithProtocol(str) {
  return /^[a-z][a-z0-9\+\-]*:/i.test(str);
}

// node_modules/vike/dist/esm/utils/checkType.js
function checkType(_) {
}

// node_modules/vike/dist/esm/utils/joinEnglish.js
function joinEnglish(arr, conjunction, colorizer = (s) => s) {
  assert(arr.length > 0);
  if (arr.length === 1)
    return colorizer(arr[0]);
  const firsts = arr.slice(0, arr.length - 1);
  const last = arr[arr.length - 1];
  return firsts.map(colorizer).join(", ") + `, ${conjunction} ` + colorizer(last);
}

// node_modules/vike/dist/esm/utils/truncateString.js
import pc5 from "@brillout/picocolors";
function truncateString(str, lenMax) {
  const lenMaxReal = lenMax - 3;
  assert(lenMaxReal >= 1);
  if (str.length < lenMax) {
    return str;
  } else {
    str = str.substring(0, lenMaxReal);
    const ellipsis = pc5.dim("...");
    str = str + ellipsis;
    return str;
  }
}

// node_modules/vike/dist/esm/shared/route/utils.js
if (isBrowser()) {
  assertClientRouting();
}

// node_modules/vike/dist/esm/shared/route/abort.js
import pc6 from "@brillout/picocolors";
function redirect(url, statusCode) {
  const abortCaller = "throw redirect()";
  assertUrl(url, abortCaller, true);
  const args = [JSON.stringify(url)];
  if (!statusCode) {
    statusCode = 302;
  } else {
    assertStatusCode(statusCode, [301, 302], "redirect");
    args.push(String(statusCode));
  }
  const pageContextAbort = {};
  objectAssign(pageContextAbort, {
    _abortCaller: abortCaller,
    _abortCall: `redirect(${args.join(", ")})`,
    _urlRedirect: {
      url,
      statusCode
    }
  });
  return AbortRender(pageContextAbort);
}
function render(urlOrStatusCode, abortReason) {
  const args = [typeof urlOrStatusCode === "number" ? String(urlOrStatusCode) : JSON.stringify(urlOrStatusCode)];
  if (abortReason !== void 0)
    args.push(truncateString(JSON.stringify(abortReason), 30));
  const abortCaller = "throw render()";
  const abortCall = `render(${args.join(", ")})`;
  return render_(urlOrStatusCode, abortReason, abortCall, abortCaller);
}
function render_(urlOrStatusCode, abortReason, abortCall, abortCaller, pageContextAddendum) {
  const pageContextAbort = {
    abortReason,
    _abortCaller: abortCaller,
    _abortCall: abortCall
  };
  if (pageContextAddendum) {
    assert(pageContextAddendum._isLegacyRenderErrorPage === true);
    objectAssign(pageContextAbort, pageContextAddendum);
  }
  if (typeof urlOrStatusCode === "string") {
    const url = urlOrStatusCode;
    assertUrl(url, abortCaller);
    objectAssign(pageContextAbort, {
      _urlRewrite: url
    });
    return AbortRender(pageContextAbort);
  } else {
    const abortStatusCode = urlOrStatusCode;
    assertStatusCode(urlOrStatusCode, [401, 403, 404, 410, 429, 500, 503], "render");
    objectAssign(pageContextAbort, {
      abortStatusCode,
      is404: abortStatusCode === 404
    });
    return AbortRender(pageContextAbort);
  }
}
function AbortRender(pageContextAbort) {
  const err = new Error("AbortRender");
  objectAssign(err, { _pageContextAbort: pageContextAbort, [stamp]: true });
  checkType(err);
  return err;
}
var stamp = "_isAbortError";
function assertStatusCode(statusCode, expected, caller) {
  const expectedEnglish = joinEnglish(expected.map((s) => s.toString()), "or");
  assertWarning2(expected.includes(statusCode), `Unepexected status code ${statusCode} passed to ${caller}(), we recommend ${expectedEnglish} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${statusCode} should be added.)`, { onlyOnce: true });
}
function assertUrl(url, abortCaller, allowAbsoluteUrl) {
  assertUsage2(url.startsWith("/") || allowAbsoluteUrl && isUriWithProtocol(url), [
    `Invalid URL ${pc6.cyan(url)} passed to ${pc6.cyan(abortCaller)}:`,
    `the URL should start with ${pc6.cyan("/")}`,
    allowAbsoluteUrl && `or a valid protocol (${pc6.cyan("https:")}, ${pc6.cyan("ipfs:")}, ...)`
  ].filter(Boolean).join(" "));
}
export {
  redirect,
  render
};
//# sourceMappingURL=vike_abort.js.map
