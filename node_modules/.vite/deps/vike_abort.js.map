{
  "version": 3,
  "sources": ["../../vike/dist/esm/utils/unique.js", "../../vike/dist/esm/utils/projectInfo.js", "../../vike/dist/esm/utils/getGlobalObject.js", "../../vike/dist/esm/utils/assertSingleInstance.js", "../../vike/dist/esm/utils/isNodeJS.js", "../../vike/dist/esm/utils/createErrorWithCleanStackTrace.js", "../../vike/dist/esm/utils/assert.js", "../../vike/dist/esm/shared/hooks/executeHook.js", "../../vike/dist/esm/utils/isBrowser.js", "../../vike/dist/esm/utils/assertRoutingType.js", "../../vike/dist/esm/utils/objectAssign.js", "../../vike/dist/esm/utils/parseUrl.js", "../../vike/dist/esm/utils/checkType.js", "../../vike/dist/esm/utils/joinEnglish.js", "../../vike/dist/esm/utils/truncateString.js", "../../vike/dist/esm/shared/route/utils.js", "../../vike/dist/esm/shared/route/abort.js"],
  "sourcesContent": ["export { unique };\nfunction unique(arr) {\n    return Array.from(new Set(arr));\n}\n", "export { projectInfo };\nexport { PROJECT_VERSION };\nconst PROJECT_VERSION = '0.4.179';\nconst projectInfo = {\n    projectName: 'Vike',\n    projectVersion: PROJECT_VERSION\n};\n", "export { getGlobalObject };\nexport { assertIsSingleModuleInstance };\nimport { assert } from './assert.js';\nimport { projectInfo } from './projectInfo.js';\nconst projectKey = `_${projectInfo.projectName.toLowerCase()}`;\n/** Share information across module instances. */\nfunction getGlobalObject(\n// We use the filename (or file path) as key. There should be only one getGlobalObject() usage per file. Thus the key should be unique, assuming the filename (or file path) is unique.\nkey, defaultValue) {\n    const globalObjects = getGlobalObjects();\n    const globalObject = (globalObjects[key] = globalObjects[key] || defaultValue);\n    return globalObject;\n}\n/** Assert that the module is instantiated only once. */\nfunction assertIsSingleModuleInstance(\n// We use the filename (or file path) as key.\nkey) {\n    const globalObjects = getGlobalObjects();\n    assert(!(key in globalObjects));\n}\nfunction getGlobalObjects() {\n    // @ts-ignore\n    const globalObjects = (globalThis[projectKey] = globalThis[projectKey] || {});\n    return globalObjects;\n}\n", "export { assertSingleInstance_onClientEntryServerRouting };\nexport { assertSingleInstance_onClientEntryClientRouting };\nexport { assertSingleInstance_onAssertModuleLoad };\n//  - Throw error if there are two different versions of vike loaded\n//  - Show warning if entry of Client Routing and entry of Server Routing are both loaded\n//  - Show warning if vike is loaded twice\nimport { unique } from './unique.js';\nimport { getGlobalObject } from './getGlobalObject.js';\nimport { projectInfo } from './projectInfo.js';\nimport pc from '@brillout/picocolors';\n/* Use original assertUsage() & assertWarning() after all CJS is removed from node_modules/vike/dist/\nimport { assertUsage, assertWarning } from './assert.js'\n*/\nconst globalObject = getGlobalObject('assertPackageInstances.ts', {\n    instances: [],\n    alreadyLogged: new Set()\n});\nconst clientRuntimesClonflict = \"The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict\";\nconst clientNotSingleInstance = \"Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)\";\nfunction assertSingleInstance() {\n    {\n        const versions = unique(globalObject.instances);\n        assertUsage(versions.length <= 1, \n        // DO *NOT* patch vike to remove this error: because of multiple conflicting versions, you *will* eventually encounter insidious issues that hard to debug and potentially a security hazard, see for example https://github.com/vikejs/vike/issues/1108\n        `vike@${pc.bold(versions[0])} and vike@${pc.bold(versions[1])} loaded but only one version should be loaded`);\n    }\n    if (globalObject.checkSingleInstance && globalObject.instances.length > 1) {\n        /*/ Not sure whether circular dependency can cause problems? In principle not since client-side code is ESM.\n        console.warn(clientNotSingleInstance)\n        /*/\n        assertWarning(false, clientNotSingleInstance, { onlyOnce: true, showStackTrace: true });\n        //*/\n    }\n}\nfunction assertSingleInstance_onClientEntryServerRouting(isProduction) {\n    assertWarning(globalObject.isClientRouting !== true, clientRuntimesClonflict, {\n        onlyOnce: true,\n        showStackTrace: true\n    });\n    assertWarning(globalObject.isClientRouting === undefined, clientNotSingleInstance, {\n        onlyOnce: true,\n        showStackTrace: true\n    });\n    globalObject.isClientRouting = false;\n    if (isProduction)\n        globalObject.checkSingleInstance = true;\n    assertSingleInstance();\n}\nfunction assertSingleInstance_onClientEntryClientRouting(isProduction) {\n    assertWarning(globalObject.isClientRouting !== false, clientRuntimesClonflict, {\n        onlyOnce: true,\n        showStackTrace: true\n    });\n    assertWarning(globalObject.isClientRouting === undefined, clientNotSingleInstance, {\n        onlyOnce: true,\n        showStackTrace: true\n    });\n    globalObject.isClientRouting = true;\n    if (isProduction)\n        globalObject.checkSingleInstance = true;\n    assertSingleInstance();\n}\n// Called by utils/assert.ts which is (most certainly) loaded by all entries. That way we don't have to call a callback for every entry. (There are a lot of entries: `client/router/`, `client/`, `node/runtime/`, `node/plugin/`, `node/cli`.)\nfunction assertSingleInstance_onAssertModuleLoad() {\n    globalObject.instances.push(projectInfo.projectVersion);\n    assertSingleInstance();\n}\nfunction assertUsage(condition, errorMessage) {\n    if (condition) {\n        return;\n    }\n    const errMsg = `[vike][Wrong Usage] ${errorMessage}`;\n    throw new Error(errMsg);\n}\nfunction assertWarning(condition, errorMessage, { onlyOnce, showStackTrace }) {\n    if (condition) {\n        return;\n    }\n    const msg = `[vike][Warning] ${errorMessage}`;\n    if (onlyOnce) {\n        const { alreadyLogged } = globalObject;\n        const key = onlyOnce === true ? msg : onlyOnce;\n        if (alreadyLogged.has(key)) {\n            return;\n        }\n        else {\n            alreadyLogged.add(key);\n        }\n    }\n    if (showStackTrace) {\n        console.warn(new Error(msg));\n    }\n    else {\n        console.warn(msg);\n    }\n}\n", "export function isNodeJS() {\n    if (typeof process === 'undefined')\n        return false;\n    if (!process.cwd)\n        return false;\n    // https://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js/35813135#35813135\n    if (!process.versions || typeof process.versions.node === 'undefined')\n        return false;\n    // https://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js/35813135#comment92529277_35813135\n    if (!process.release || process.release.name !== 'node')\n        return false;\n    return true;\n}\n", "export { createErrorWithCleanStackTrace };\nimport { isNodeJS } from './isNodeJS.js';\nfunction createErrorWithCleanStackTrace(errorMessage, numberOfStackTraceLinesToRemove) {\n    const err = new Error(errorMessage);\n    if (isNodeJS()) {\n        err.stack = clean(err.stack, numberOfStackTraceLinesToRemove);\n    }\n    return err;\n}\nfunction clean(errStack, numberOfStackTraceLinesToRemove) {\n    if (!errStack) {\n        return errStack;\n    }\n    const stackLines = splitByLine(errStack);\n    let linesRemoved = 0;\n    const stackLine__cleaned = stackLines\n        .filter((line) => {\n        // Remove internal stack traces\n        if (line.includes(' (internal/') || line.includes(' (node:internal')) {\n            return false;\n        }\n        if (linesRemoved < numberOfStackTraceLinesToRemove && isStackTraceLine(line)) {\n            linesRemoved++;\n            return false;\n        }\n        return true;\n    })\n        .join('\\n');\n    return stackLine__cleaned;\n}\nfunction isStackTraceLine(line) {\n    return line.startsWith('    at ');\n}\nfunction splitByLine(str) {\n    // https://stackoverflow.com/questions/21895233/how-in-node-to-split-string-by-newline-n\n    return str.split(/\\r?\\n/);\n}\n", "export { assert };\nexport { assertUsage };\nexport { assertWarning };\nexport { assertInfo };\nexport { getProjectError };\nexport { addOnBeforeLogHook };\nexport { getAssertErrMsg };\nexport { overwriteAssertProductionLogger };\nexport { isBug };\nexport { setAlwaysShowStackTrace };\nimport { assertSingleInstance_onAssertModuleLoad } from './assertSingleInstance.js';\nimport { createErrorWithCleanStackTrace } from './createErrorWithCleanStackTrace.js';\nimport { getGlobalObject } from './getGlobalObject.js';\nimport { isObject } from './isObject.js';\nimport { projectInfo } from './projectInfo.js';\nimport pc from '@brillout/picocolors';\nconst globalObject = getGlobalObject('utils/assert.ts', {\n    alreadyLogged: new Set(),\n    // Production logger. Overwritten by loggerNotProd.ts in non-production environments.\n    logger(msg, logType) {\n        if (logType === 'info') {\n            console.log(msg);\n        }\n        else {\n            console.warn(msg);\n        }\n    },\n    showStackTraceList: new WeakSet()\n});\nassertSingleInstance_onAssertModuleLoad();\nconst projectTag = `[vike]`;\nconst projectTagWithVersion = `[vike@${projectInfo.projectVersion}]`;\nconst numberOfStackTraceLinesToRemove = 2;\nfunction assert(condition, debugInfo) {\n    if (condition)\n        return;\n    const debugStr = (() => {\n        if (!debugInfo) {\n            return null;\n        }\n        const debugInfoSerialized = typeof debugInfo === 'string' ? debugInfo : JSON.stringify(debugInfo);\n        return pc.dim(`Debug info (for Vike maintainers; you can ignore this): ${debugInfoSerialized}`);\n    })();\n    const link = pc.blue('https://github.com/vikejs/vike/issues/new');\n    let errMsg = [\n        `You stumbled upon a Vike bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,\n        debugStr\n    ]\n        .filter(Boolean)\n        .join(' ');\n    errMsg = addWhitespace(errMsg);\n    errMsg = addPrefixAssertType(errMsg, 'Bug');\n    errMsg = addPrefixProjctName(errMsg, true);\n    const internalError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);\n    globalObject.onBeforeLog?.();\n    throw internalError;\n}\nfunction assertUsage(condition, errMsg, { showStackTrace } = {}) {\n    if (condition)\n        return;\n    showStackTrace = showStackTrace || globalObject.alwaysShowStackTrace;\n    errMsg = addWhitespace(errMsg);\n    errMsg = addPrefixAssertType(errMsg, 'Wrong Usage');\n    errMsg = addPrefixProjctName(errMsg);\n    const usageError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);\n    if (showStackTrace) {\n        globalObject.showStackTraceList.add(usageError);\n    }\n    globalObject.onBeforeLog?.();\n    throw usageError;\n}\nfunction getProjectError(errMsg) {\n    errMsg = addWhitespace(errMsg);\n    errMsg = addPrefixAssertType(errMsg, 'Error');\n    errMsg = addPrefixProjctName(errMsg);\n    const projectError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);\n    return projectError;\n}\nfunction assertWarning(condition, msg, { onlyOnce, showStackTrace }) {\n    if (condition)\n        return;\n    showStackTrace = showStackTrace || globalObject.alwaysShowStackTrace;\n    msg = addWhitespace(msg);\n    msg = addPrefixAssertType(msg, 'Warning');\n    msg = addPrefixProjctName(msg);\n    if (onlyOnce) {\n        const { alreadyLogged } = globalObject;\n        const key = onlyOnce === true ? msg : onlyOnce;\n        if (alreadyLogged.has(key)) {\n            return;\n        }\n        else {\n            alreadyLogged.add(key);\n        }\n    }\n    globalObject.onBeforeLog?.();\n    if (showStackTrace) {\n        const err = createErrorWithCleanStackTrace(msg, numberOfStackTraceLinesToRemove);\n        globalObject.showStackTraceList.add(err);\n        globalObject.logger(err, 'warn');\n    }\n    else {\n        globalObject.logger(msg, 'warn');\n    }\n}\nfunction assertInfo(condition, msg, { onlyOnce }) {\n    if (condition) {\n        return;\n    }\n    msg = addWhitespace(msg);\n    msg = addPrefixProjctName(msg);\n    if (onlyOnce) {\n        const { alreadyLogged } = globalObject;\n        const key = msg;\n        if (alreadyLogged.has(key)) {\n            return;\n        }\n        else {\n            alreadyLogged.add(key);\n        }\n    }\n    globalObject.onBeforeLog?.();\n    globalObject.logger(msg, 'info');\n}\nfunction addOnBeforeLogHook(onBeforeLog) {\n    globalObject.onBeforeLog = onBeforeLog;\n}\nfunction addPrefixAssertType(msg, tag) {\n    let prefix = `[${tag}]`;\n    const color = tag === 'Warning' ? 'yellow' : 'red';\n    prefix = pc.bold(pc[color](prefix));\n    return `${prefix}${msg}`;\n}\nfunction addWhitespace(msg) {\n    if (msg.startsWith('[')) {\n        return msg;\n    }\n    else {\n        return ` ${msg}`;\n    }\n}\nfunction addPrefixProjctName(msg, showProjectVersion = false) {\n    const prefix = showProjectVersion ? projectTagWithVersion : projectTag;\n    return `${prefix}${msg}`;\n}\nfunction getAssertErrMsg(thing) {\n    let errMsg;\n    let errStack = null;\n    if (typeof thing === 'string') {\n        errMsg = thing;\n    }\n    else if (isObject(thing) && typeof thing.message === 'string' && typeof thing.stack === 'string') {\n        errMsg = thing.message;\n        errStack = thing.stack;\n    }\n    else {\n        return null;\n    }\n    let assertMsg;\n    let isBug;\n    if (errMsg.startsWith(projectTag)) {\n        assertMsg = errMsg.slice(projectTag.length);\n        isBug = false;\n    }\n    else if (errMsg.startsWith(projectTagWithVersion)) {\n        assertMsg = errMsg.slice(projectTagWithVersion.length);\n        isBug = true;\n    }\n    else {\n        return null;\n    }\n    // Append stack trace\n    if (errStack && (isBug || globalObject.showStackTraceList.has(thing))) {\n        assertMsg = `${assertMsg}\\n${removeErrMsg(errStack)}`;\n    }\n    const showVikeVersion = isBug;\n    return { assertMsg, showVikeVersion };\n}\nfunction removeErrMsg(stack) {\n    if (typeof stack !== 'string')\n        return String(stack);\n    const [firstLine, ...stackLines] = stack.split('\\n');\n    if (!firstLine.startsWith('Error: '))\n        return stack;\n    return stackLines.join('\\n');\n}\nfunction overwriteAssertProductionLogger(logger) {\n    globalObject.logger = logger;\n}\nfunction isBug(err) {\n    return !String(err).includes('[Bug]');\n}\nfunction setAlwaysShowStackTrace() {\n    globalObject.alwaysShowStackTrace = true;\n}\n", "export { executeHook };\nexport { getPageContext };\nexport { isUserHookError };\nimport { getProjectError, assertWarning } from '../../utils/assert.js';\nimport { getGlobalObject } from '../../utils/getGlobalObject.js';\nimport { humanizeTime } from '../../utils/humanizeTime.js';\nimport { isObject } from '../../utils/isObject.js';\nconst globalObject = getGlobalObject('utils/executeHook.ts', {\n    userHookErrors: new WeakMap(),\n    pageContext: null\n});\nfunction isUserHookError(err) {\n    if (!isObject(err))\n        return false;\n    return globalObject.userHookErrors.get(err) ?? false;\n}\nfunction executeHook(hookFnCaller, hook, pageContext) {\n    const { hookName, hookFilePath, hookTimeout: { error: timeoutErr, warning: timeoutWarn } } = hook;\n    let resolve;\n    let reject;\n    const promise = new Promise((resolve_, reject_) => {\n        resolve = (ret) => {\n            clearTimeouts();\n            resolve_(ret);\n        };\n        reject = (err) => {\n            clearTimeouts();\n            reject_(err);\n        };\n    });\n    const clearTimeouts = () => {\n        if (currentTimeoutWarn)\n            clearTimeout(currentTimeoutWarn);\n        if (currentTimeoutErr)\n            clearTimeout(currentTimeoutErr);\n    };\n    const currentTimeoutWarn = isNotDisabled(timeoutWarn) &&\n        setTimeout(() => {\n            assertWarning(false, `The ${hookName}() hook defined by ${hookFilePath} is slow: it's taking more than ${humanizeTime(timeoutWarn)} (https://vike.dev/hooksTimeout)`, { onlyOnce: false });\n        }, timeoutWarn);\n    const currentTimeoutErr = isNotDisabled(timeoutErr) &&\n        setTimeout(() => {\n            const err = getProjectError(`The ${hookName}() hook defined by ${hookFilePath} timed out: it didn't finish after ${humanizeTime(timeoutErr)} (https://vike.dev/hooksTimeout)`);\n            reject(err);\n        }, timeoutErr);\n    (async () => {\n        try {\n            providePageContext(pageContext);\n            const ret = await hookFnCaller();\n            resolve(ret);\n        }\n        catch (err) {\n            if (isObject(err)) {\n                globalObject.userHookErrors.set(err, { hookName, hookFilePath });\n            }\n            reject(err);\n        }\n    })();\n    return promise;\n}\nfunction isNotDisabled(timeout) {\n    return !!timeout && timeout !== Infinity;\n}\n/**\n * Access `pageContext` object inside Vike hooks, in order to create universal hooks.\n *\n * https://vike.dev/getPageContext\n */\nfunction getPageContext() {\n    return globalObject.pageContext;\n}\nfunction providePageContext(pageContext) {\n    globalObject.pageContext = pageContext;\n    // Promise.resolve() is quicker than process.nextTick() and setImmediate()\n    // https://stackoverflow.com/questions/67949576/process-nexttick-before-promise-resolve-then\n    Promise.resolve().then(() => {\n        globalObject.pageContext = null;\n    });\n}\n", "export function isBrowser() {\n    // Using `typeof window !== 'undefined'` alone is not enough because some users use https://www.npmjs.com/package/ssr-window\n    return typeof window !== 'undefined' && typeof window.scrollY === 'number';\n    // Alternatively, test whether environment is a *real* browser: https://github.com/brillout/picocolors/blob/d59a33a0fd52a8a33e4158884069192a89ce0113/picocolors.js#L87-L89\n}\n", "export { assertClientRouting };\nexport { assertServerRouting };\nexport { checkIfClientRouting };\nimport { assertUsage, assertWarning } from './assert.js';\nimport { getGlobalObject } from './getGlobalObject.js';\nimport { isBrowser } from './isBrowser.js';\nimport pc from '@brillout/picocolors';\nconst state = getGlobalObject('utils/assertRouterType.ts', {});\nfunction assertClientRouting() {\n    assertNoContradiction(checkIfClientRouting());\n    state.isClientRouting = true;\n}\nfunction checkIfClientRouting() {\n    return state.isClientRouting !== false;\n}\nfunction assertServerRouting() {\n    assertNoContradiction(state.isClientRouting !== true);\n    state.isClientRouting = false;\n}\nfunction assertNoContradiction(noContradiction) {\n    // If an assertion fails because of a wrong usage, then we assume that the user is trying to import from 'vike/client/router' while not setting `clientRouting` to `true`. Note that 'vike/client' only exports the type `PageContextBuiltInClient` and that the package.json#exports entry 'vike/client' will eventually be removed.\n    assertUsage(isBrowser(), `${pc.cyan(\"import { something } from 'vike/client/router'\")} is forbidden on the server-side`, { showStackTrace: true });\n    assertWarning(noContradiction, \"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.\", { showStackTrace: true, onlyOnce: true });\n}\n", "export { objectAssign };\n// Same as Object.assign() but:\n//  - With type inference\n//  - Preserves property descriptors, which we need for preserving the getters added by getPageContextUrlComputed()\nfunction objectAssign(obj, objAddendum) {\n    if (objAddendum) {\n        Object.defineProperties(obj, Object.getOwnPropertyDescriptors(objAddendum));\n    }\n}\n", "// We don't use new URL() as it doesn't exactly do what we need, for example:\n//  - It loses the original URL parts (which we need to manipulate and recreate URLs)\n//  - It doesn't support the tauri:// protocol\n// Unit tests at ./parseUrl.spec.ts\nexport { parseUrl };\nexport { isParsable };\nexport { assertUsageUrl };\nexport { isBaseServer };\nexport { assertUrlComponents };\nexport { createUrlFromComponents };\nexport { isUriWithProtocol };\nimport { slice } from './slice.js';\nimport { assert, assertUsage } from './assert.js';\nimport pc from '@brillout/picocolors';\nfunction isParsable(url) {\n    // `parseUrl()` works with these URLs\n    return (isUrlWithProtocol(url) ||\n        url.startsWith('/') ||\n        url.startsWith('.') ||\n        url.startsWith('?') ||\n        url.startsWith('#') ||\n        url === '');\n}\nfunction assertUsageUrl(url, errPrefix) {\n    assert(errPrefix.includes(' but '));\n    assertUsage(typeof url === 'string', `${errPrefix} should be a string`);\n    if (isParsable(url))\n        return;\n    if (!url.startsWith('/') && !url.includes(':')) {\n        assertUsage(false, `${errPrefix} is ${pc.cyan(url)} and it should be /${pc.cyan(url)} instead (URL pathnames should start with a leading slash)`);\n    }\n    else {\n        assertUsage(false, `${errPrefix} isn't a valid URL`);\n    }\n}\nfunction parseUrl(url, baseServer) {\n    assert(isParsable(url));\n    assert(baseServer.startsWith('/'));\n    // Hash\n    const [urlWithoutHash, ...hashList] = url.split('#');\n    assert(urlWithoutHash !== undefined);\n    const hashOriginal = ['', ...hashList].join('#') || null;\n    assert(hashOriginal === null || hashOriginal.startsWith('#'));\n    const hash = hashOriginal === null ? '' : decodeSafe(hashOriginal.slice(1));\n    // Search\n    const [urlWithoutHashNorSearch, ...searchList] = urlWithoutHash.split('?');\n    assert(urlWithoutHashNorSearch !== undefined);\n    const searchOriginal = ['', ...searchList].join('?') || null;\n    assert(searchOriginal === null || searchOriginal.startsWith('?'));\n    const search = {};\n    const searchAll = {};\n    Array.from(new URLSearchParams(searchOriginal || '')).forEach(([key, val]) => {\n        search[key] = val;\n        searchAll[key] = [...(searchAll.hasOwnProperty(key) ? searchAll[key] : []), val];\n    });\n    // Origin + pathname\n    const { origin, pathname: pathnameResolved } = getPathname(urlWithoutHashNorSearch, baseServer);\n    assert(origin === null || origin === decodeSafe(origin)); // AFAICT decoding the origin is useless\n    assert(pathnameResolved.startsWith('/'));\n    assert(origin === null || url.startsWith(origin));\n    // `pathnameOriginal`\n    const pathnameOriginal = urlWithoutHashNorSearch.slice((origin || '').length);\n    assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal);\n    // Base URL\n    let { pathname, hasBaseServer } = analyzeBaseServer(pathnameResolved, baseServer);\n    pathname = decodePathname(pathname);\n    assert(pathname.startsWith('/'));\n    return {\n        origin,\n        pathname,\n        pathnameOriginal: pathnameOriginal,\n        hasBaseServer,\n        search,\n        searchAll,\n        searchOriginal,\n        hash,\n        hashOriginal\n    };\n}\nfunction decodeSafe(urlComponent) {\n    try {\n        return decodeURIComponent(urlComponent);\n    }\n    catch { }\n    try {\n        return decodeURI(urlComponent);\n    }\n    catch { }\n    return urlComponent;\n}\nfunction decodePathname(urlPathname) {\n    urlPathname = urlPathname.replace(/\\s+$/, '');\n    urlPathname = urlPathname\n        .split('/')\n        .map((dir) => decodeSafe(dir).split('/').join('%2F'))\n        .join('/');\n    return urlPathname;\n}\nfunction getPathname(url, baseServer) {\n    // Search and hash already extracted\n    assert(!url.includes('?') && !url.includes('#'));\n    // url has origin\n    {\n        const { origin, pathname } = parseOrigin(url);\n        if (origin) {\n            return { origin, pathname };\n        }\n        assert(pathname === url);\n    }\n    // url doesn't have origin\n    if (url.startsWith('/')) {\n        return { origin: null, pathname: url };\n    }\n    else {\n        // url is a relative path\n        // In the browser, this is the Base URL of the current URL.\n        // Safe access `window?.document?.baseURI` for users who shim `window` in Node.js\n        const baseURI = typeof window !== 'undefined' ? window?.document?.baseURI : undefined;\n        let base;\n        if (baseURI) {\n            const baseURIPathaname = parseOrigin(baseURI.split('?')[0]).pathname;\n            base = baseURIPathaname;\n        }\n        else {\n            base = baseServer;\n        }\n        const pathname = resolveUrlPathnameRelative(url, base);\n        return { origin: null, pathname };\n    }\n}\nfunction parseOrigin(url) {\n    if (!isUrlWithProtocol(url)) {\n        assert(!isUriWithProtocol(url));\n        return { pathname: url, origin: null };\n    }\n    else {\n        const [originPart1, originPart2, originPart3, ...pathnameParts] = url.split('/');\n        const origin = [originPart1, originPart2, originPart3].join('/');\n        const pathname = ['', ...pathnameParts].join('/') || '/';\n        return { origin, pathname };\n    }\n}\n// Adapted from https://stackoverflow.com/questions/14780350/convert-relative-path-to-absolute-using-javascript/14780463#14780463\nfunction resolveUrlPathnameRelative(pathnameRelative, base) {\n    const stack = base.split('/');\n    const parts = pathnameRelative.split('/');\n    let baseRestoreTrailingSlash = base.endsWith('/');\n    if (pathnameRelative.startsWith('.')) {\n        // remove current file name\n        stack.pop();\n    }\n    for (const i in parts) {\n        const p = parts[i];\n        if (p == '' && i === '0')\n            continue;\n        if (p == '.')\n            continue;\n        if (p == '..')\n            stack.pop();\n        else {\n            baseRestoreTrailingSlash = false;\n            stack.push(p);\n        }\n    }\n    let pathnameAbsolute = stack.join('/');\n    if (baseRestoreTrailingSlash && !pathnameAbsolute.endsWith('/'))\n        pathnameAbsolute += '/';\n    if (!pathnameAbsolute.startsWith('/'))\n        pathnameAbsolute = '/' + pathnameAbsolute;\n    return pathnameAbsolute;\n}\n/* Not needed anymore?\nfunction assertUsageBaseServer(baseServer: string, usageErrorMessagePrefix: string = '') {\n  assertUsage(\n    !baseServer.startsWith('http'),\n    usageErrorMessagePrefix +\n      '`base` is not allowed to start with `http`. Consider using `baseAssets` instead, see https://vike.dev/base-url'\n  )\n  assertUsage(\n    baseServer.startsWith('/'),\n    usageErrorMessagePrefix + 'Wrong `base` value `' + baseServer + '`; `base` should start with `/`.'\n  )\n  assert(isBaseServer(baseServer))\n}\n*/\nfunction assertPathname(urlPathname) {\n    assert(urlPathname.startsWith('/'));\n    assert(!urlPathname.includes('?'));\n    assert(!urlPathname.includes('#'));\n}\nfunction analyzeBaseServer(urlPathnameWithBase, baseServer) {\n    assertPathname(urlPathnameWithBase);\n    assert(isBaseServer(baseServer));\n    // Mutable\n    let urlPathname = urlPathnameWithBase;\n    assert(urlPathname.startsWith('/'));\n    assert(baseServer.startsWith('/'));\n    if (baseServer === '/') {\n        const pathname = urlPathnameWithBase;\n        return { pathname, hasBaseServer: true };\n    }\n    // Support `url === '/some-base-url' && baseServer === '/some-base-url/'`\n    let baseServerNormalized = baseServer;\n    if (baseServer.endsWith('/') && urlPathname === slice(baseServer, 0, -1)) {\n        baseServerNormalized = slice(baseServer, 0, -1);\n        assert(urlPathname === baseServerNormalized);\n    }\n    if (!urlPathname.startsWith(baseServerNormalized)) {\n        const pathname = urlPathnameWithBase;\n        return { pathname, hasBaseServer: false };\n    }\n    assert(urlPathname.startsWith('/') || urlPathname.startsWith('http'));\n    assert(urlPathname.startsWith(baseServerNormalized));\n    urlPathname = urlPathname.slice(baseServerNormalized.length);\n    if (!urlPathname.startsWith('/'))\n        urlPathname = '/' + urlPathname;\n    assert(urlPathname.startsWith('/'));\n    return { pathname: urlPathname, hasBaseServer: true };\n}\nfunction isBaseServer(baseServer) {\n    return baseServer.startsWith('/');\n}\nfunction assertUrlComponents(url, origin, pathname, searchOriginal, hashOriginal) {\n    const urlRecreated = createUrlFromComponents(origin, pathname, searchOriginal, hashOriginal);\n    assert(url === urlRecreated);\n}\nfunction createUrlFromComponents(origin, pathname, searchOriginal, hashOriginal) {\n    const urlRecreated = `${origin || ''}${pathname}${searchOriginal || ''}${hashOriginal || ''}`;\n    return urlRecreated;\n}\nfunction isUriWithProtocol(str) {\n    // https://en.wikipedia.org/wiki/List_of_URI_schemes\n    // https://www.rfc-editor.org/rfc/rfc7595\n    // https://github.com/vikejs/vike/commit/886a99ff21e86a8ca699a25cee7edc184aa058e4#r143308934\n    // Examples:\n    //   http://\n    //   https://\n    //   tauri:// # [Tauri](https://tauri.app)\n    //   file:// # [Electron](https://github.com/vikejs/vike/issues/1557)\n    //   capacitor:// # [Capacitor](https://github.com/vikejs/vike/issues/1706)\n    return /^[a-z][a-z0-9\\+\\-]*:/i.test(str);\n}\n// Same as isUriWithProtocol() but with trailing :// which is needed for parseOrigin()\nfunction isUrlWithProtocol(str) {\n    return /^[a-z][a-z0-9\\+\\-]*:\\/\\//i.test(str);\n}\n", "export function checkType(_) { }\nexport function castType(_) { }\n", "export { joinEnglish };\nimport { assert } from './assert.js';\n// https://stackoverflow.com/questions/53879088/join-an-array-by-commas-and-and/53879103#53879103\nfunction joinEnglish(arr, conjunction, colorizer = (s) => s) {\n    assert(arr.length > 0);\n    if (arr.length === 1)\n        return colorizer(arr[0]);\n    const firsts = arr.slice(0, arr.length - 1);\n    const last = arr[arr.length - 1];\n    return firsts.map(colorizer).join(', ') + `, ${conjunction} ` + colorizer(last);\n}\n", "export { truncateString };\nimport pc from '@brillout/picocolors';\nimport { assert } from './assert.js';\nfunction truncateString(str, lenMax) {\n    const lenMaxReal = lenMax - 3;\n    assert(lenMaxReal >= 1); // Show at least one character before the ellipsis\n    if (str.length < lenMax) {\n        return str;\n    }\n    else {\n        // Breaks ANSI codes.\n        //  - So far, the `str` we pass to truncateString(str) is always expected to not contain any ANSI code\n        str = str.substring(0, lenMaxReal);\n        const ellipsis = pc.dim('...');\n        str = str + ellipsis;\n        return str;\n    }\n}\n", "// Utils needed by:\n//  - runtime of server\n//  - runtime of client (Client Routing)\n// Ensure we don't bloat runtime of Server Routing with the utils down below\nimport { assertClientRouting } from '../../utils/assertRoutingType.js';\nimport { isBrowser } from '../../utils/isBrowser.js';\nif (isBrowser()) {\n    assertClientRouting();\n}\nexport * from '../../utils/assert.js';\nexport * from '../../utils/hasProp.js';\nexport * from '../../utils/isObjectWithKeys.js';\nexport * from '../../utils/sorter.js';\nexport * from '../../utils/isPromise.js';\nexport * from '../../utils/isPlainObject.js';\nexport * from '../../utils/objectAssign.js';\nexport * from '../../utils/slice.js';\nexport * from '../../utils/unique.js';\nexport * from '../../utils/isBrowser.js';\nexport * from '../../utils/parseUrl.js';\nexport * from '../../utils/checkType.js';\nexport * from '../../utils/joinEnglish.js';\nexport * from '../../utils/projectInfo.js';\nexport * from '../../utils/truncateString.js';\nexport * from '../../utils/isCallable.js';\n", "export { redirect };\nexport { render };\nexport { RenderErrorPage };\nexport { isAbortError };\nexport { isAbortPageContext };\nexport { logAbortErrorHandled };\nexport { getPageContextFromAllRewrites };\nexport { AbortRender };\nexport { assertNoInfiniteAbortLoop };\nimport { isUserHookError } from '../hooks/executeHook.js';\nimport { assert, assertInfo, assertUsage, assertWarning, checkType, hasProp, isUriWithProtocol, joinEnglish, objectAssign, truncateString } from './utils.js';\nimport pc from '@brillout/picocolors';\n/**\n * Abort the rendering of the current page, and redirect the user to another URL instead.\n *\n * https://vike.dev/redirect\n *\n * @param url The URL to redirect to.\n * @param statusCode By default a temporary redirection (`302`) is performed. For permanent redirections (`301`), use `config.redirects` https://vike.dev/redirects instead or, alternatively, set the `statusCode` argument to `301`.\n */\nfunction redirect(url, statusCode) {\n    const abortCaller = 'throw redirect()';\n    assertUrl(url, abortCaller, true);\n    const args = [JSON.stringify(url)];\n    if (!statusCode) {\n        statusCode = 302;\n    }\n    else {\n        assertStatusCode(statusCode, [301, 302], 'redirect');\n        args.push(String(statusCode));\n    }\n    const pageContextAbort = {};\n    objectAssign(pageContextAbort, {\n        _abortCaller: abortCaller,\n        _abortCall: `redirect(${args.join(', ')})`,\n        _urlRedirect: {\n            url,\n            statusCode\n        }\n    });\n    return AbortRender(pageContextAbort);\n}\nfunction render(urlOrStatusCode, abortReason) {\n    const args = [typeof urlOrStatusCode === 'number' ? String(urlOrStatusCode) : JSON.stringify(urlOrStatusCode)];\n    if (abortReason !== undefined)\n        args.push(truncateString(JSON.stringify(abortReason), 30));\n    const abortCaller = 'throw render()';\n    const abortCall = `render(${args.join(', ')})`;\n    return render_(urlOrStatusCode, abortReason, abortCall, abortCaller);\n}\nfunction render_(urlOrStatusCode, abortReason, abortCall, abortCaller, pageContextAddendum) {\n    const pageContextAbort = {\n        abortReason,\n        _abortCaller: abortCaller,\n        _abortCall: abortCall\n    };\n    if (pageContextAddendum) {\n        assert(pageContextAddendum._isLegacyRenderErrorPage === true);\n        objectAssign(pageContextAbort, pageContextAddendum);\n    }\n    if (typeof urlOrStatusCode === 'string') {\n        const url = urlOrStatusCode;\n        assertUrl(url, abortCaller);\n        objectAssign(pageContextAbort, {\n            _urlRewrite: url\n        });\n        return AbortRender(pageContextAbort);\n    }\n    else {\n        const abortStatusCode = urlOrStatusCode;\n        assertStatusCode(urlOrStatusCode, [401, 403, 404, 410, 429, 500, 503], 'render');\n        objectAssign(pageContextAbort, {\n            abortStatusCode,\n            is404: abortStatusCode === 404\n        });\n        return AbortRender(pageContextAbort);\n    }\n}\nfunction AbortRender(pageContextAbort) {\n    const err = new Error('AbortRender');\n    objectAssign(err, { _pageContextAbort: pageContextAbort, [stamp]: true });\n    checkType(err);\n    return err;\n}\n// TODO/v1-release: remove\n/**\n * @deprecated Use `throw render()` or `throw redirect()` instead, see https://vike.dev/render'\n */\nfunction RenderErrorPage({ pageContext = {} } = {}) {\n    assertWarning(false, `${pc.cyan('throw RenderErrorPage()')} is deprecated and will be removed in the next major release. Use ${pc.cyan('throw render()')} or ${pc.cyan('throw redirect()')} instead, see https://vike.dev/render`, { onlyOnce: false });\n    let abortStatusCode = 404;\n    let abortReason = 'Page Not Found';\n    if (pageContext.is404 === false || pageContext.pageProps?.is404 === false) {\n        abortStatusCode = 500;\n        abortReason = 'Something went wrong';\n    }\n    objectAssign(pageContext, { _isLegacyRenderErrorPage: true });\n    return render_(abortStatusCode, abortReason, 'RenderErrorPage()', 'throw RenderErrorPage()', pageContext);\n}\nconst stamp = '_isAbortError';\nfunction isAbortError(thing) {\n    return typeof thing === 'object' && thing !== null && stamp in thing;\n}\nfunction isAbortPageContext(pageContext) {\n    if (!(pageContext._urlRewrite || pageContext._urlRedirect || pageContext.abortStatusCode)) {\n        return false;\n    }\n    assert(hasProp(pageContext, '_abortCall', 'string'));\n    /* Isn't needed and is missing on the client-side\n    assert(hasProp(pageContext, '_abortCaller', 'string'))\n    */\n    checkType(pageContext);\n    return true;\n}\nfunction logAbortErrorHandled(err, isProduction, pageContext) {\n    if (isProduction)\n        return;\n    const urlCurrent = pageContext._urlRewrite ?? pageContext.urlOriginal;\n    assert(urlCurrent);\n    const abortCall = err._pageContextAbort._abortCall;\n    assert(abortCall);\n    const hookLoc = isUserHookError(err);\n    let thrownBy = '';\n    if (hookLoc) {\n        thrownBy = ` by ${pc.cyan(`${hookLoc.hookName}()`)} hook defined at ${hookLoc.hookFilePath}`;\n    }\n    else {\n        // hookLoc is missing when serializing abort errors from server to client\n    }\n    assertInfo(false, `${pc.cyan(abortCall)} thrown${thrownBy} while rendering ${pc.cyan(urlCurrent)}`, {\n        onlyOnce: false\n    });\n}\nfunction assertStatusCode(statusCode, expected, caller) {\n    const expectedEnglish = joinEnglish(expected.map((s) => s.toString()), 'or');\n    assertWarning(expected.includes(statusCode), `Unepexected status code ${statusCode} passed to ${caller}(), we recommend ${expectedEnglish} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${statusCode} should be added.)`, { onlyOnce: true });\n}\nfunction getPageContextFromAllRewrites(pageContextsFromRewrite) {\n    assertNoInfiniteLoop(pageContextsFromRewrite);\n    const pageContextFromAllRewrites = { _urlRewrite: null };\n    pageContextsFromRewrite.forEach((pageContextFromRewrite) => {\n        Object.assign(pageContextFromAllRewrites, pageContextFromRewrite);\n    });\n    return pageContextFromAllRewrites;\n}\nfunction assertNoInfiniteLoop(pageContextsFromRewrite) {\n    const urlRewrites = [];\n    pageContextsFromRewrite.forEach((pageContext) => {\n        const urlRewrite = pageContext._urlRewrite;\n        {\n            const idx = urlRewrites.indexOf(urlRewrite);\n            if (idx !== -1) {\n                const loop = [...urlRewrites.slice(idx), urlRewrite].map((url) => `render('${url}')`).join(' => ');\n                assertUsage(false, `Infinite loop of render() calls: ${loop}`);\n            }\n        }\n        urlRewrites.push(urlRewrite);\n    });\n}\nfunction assertNoInfiniteAbortLoop(rewriteCount, redirectCount) {\n    const abortCalls = [\n        // prettier-ignore\n        // biome-ignore format:\n        rewriteCount > 0 && pc.cyan(\"throw render('/some-url')\"),\n        redirectCount > 0 && pc.cyan(\"throw redirect('/some-url')\")\n    ]\n        .filter(Boolean)\n        .join(' and ');\n    assertUsage(rewriteCount + redirectCount <= 7, `Maximum chain length of 7 ${abortCalls} exceeded. Did you define an infinite loop of ${abortCalls}?`);\n}\nfunction assertUrl(url, abortCaller, allowAbsoluteUrl) {\n    assertUsage(url.startsWith('/') || (allowAbsoluteUrl && isUriWithProtocol(url)), [\n        `Invalid URL ${pc.cyan(url)} passed to ${pc.cyan(abortCaller)}:`,\n        `the URL should start with ${pc.cyan('/')}`,\n        allowAbsoluteUrl && `or a valid protocol (${pc.cyan('https:')}, ${pc.cyan('ipfs:')}, ...)`\n    ]\n        .filter(Boolean)\n        .join(' '));\n}\n"],
  "mappings": ";;;AACA,SAAS,OAAO,KAAK;AACjB,SAAO,MAAM,KAAK,IAAI,IAAI,GAAG,CAAC;AAClC;;;ACDA,IAAM,kBAAkB;AACxB,IAAM,cAAc;AAAA,EAChB,aAAa;AAAA,EACb,gBAAgB;AACpB;;;ACFA,IAAM,aAAa,IAAI,YAAY,YAAY,YAAY,CAAC;AAE5D,SAAS,gBAET,KAAK,cAAc;AACf,QAAM,gBAAgB,iBAAiB;AACvC,QAAMA,gBAAgB,cAAc,GAAG,IAAI,cAAc,GAAG,KAAK;AACjE,SAAOA;AACX;AAQA,SAAS,mBAAmB;AAExB,QAAM,gBAAiB,WAAW,UAAU,IAAI,WAAW,UAAU,KAAK,CAAC;AAC3E,SAAO;AACX;;;ACfA,OAAO,QAAQ;AAIf,IAAM,eAAe,gBAAgB,6BAA6B;AAAA,EAC9D,WAAW,CAAC;AAAA,EACZ,eAAe,oBAAI,IAAI;AAC3B,CAAC;AAED,IAAM,0BAA0B;AAChC,SAAS,uBAAuB;AAC5B;AACI,UAAM,WAAW,OAAO,aAAa,SAAS;AAC9C;AAAA,MAAY,SAAS,UAAU;AAAA;AAAA,MAE/B,QAAQ,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,aAAa,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC;AAAA,IAA+C;AAAA,EAChH;AACA,MAAI,aAAa,uBAAuB,aAAa,UAAU,SAAS,GAAG;AAIvE,kBAAc,OAAO,yBAAyB,EAAE,UAAU,MAAM,gBAAgB,KAAK,CAAC;AAAA,EAE1F;AACJ;AA8BA,SAAS,0CAA0C;AAC/C,eAAa,UAAU,KAAK,YAAY,cAAc;AACtD,uBAAqB;AACzB;AACA,SAAS,YAAY,WAAW,cAAc;AAC1C,MAAI,WAAW;AACX;AAAA,EACJ;AACA,QAAM,SAAS,uBAAuB,YAAY;AAClD,QAAM,IAAI,MAAM,MAAM;AAC1B;AACA,SAAS,cAAc,WAAW,cAAc,EAAE,UAAU,eAAe,GAAG;AAC1E,MAAI,WAAW;AACX;AAAA,EACJ;AACA,QAAM,MAAM,mBAAmB,YAAY;AAC3C,MAAI,UAAU;AACV,UAAM,EAAE,cAAc,IAAI;AAC1B,UAAM,MAAM,aAAa,OAAO,MAAM;AACtC,QAAI,cAAc,IAAI,GAAG,GAAG;AACxB;AAAA,IACJ,OACK;AACD,oBAAc,IAAI,GAAG;AAAA,IACzB;AAAA,EACJ;AACA,MAAI,gBAAgB;AAChB,YAAQ,KAAK,IAAI,MAAM,GAAG,CAAC;AAAA,EAC/B,OACK;AACD,YAAQ,KAAK,GAAG;AAAA,EACpB;AACJ;;;AC/FO,SAAS,WAAW;AACvB,MAAI,OAAO,YAAY;AACnB,WAAO;AACX,MAAI,CAAC,QAAQ;AACT,WAAO;AAEX,MAAI,CAAC,QAAQ,YAAY,OAAO,QAAQ,SAAS,SAAS;AACtD,WAAO;AAEX,MAAI,CAAC,QAAQ,WAAW,QAAQ,QAAQ,SAAS;AAC7C,WAAO;AACX,SAAO;AACX;;;ACVA,SAAS,+BAA+B,cAAcC,kCAAiC;AACnF,QAAM,MAAM,IAAI,MAAM,YAAY;AAClC,MAAI,SAAS,GAAG;AACZ,QAAI,QAAQ,MAAM,IAAI,OAAOA,gCAA+B;AAAA,EAChE;AACA,SAAO;AACX;AACA,SAAS,MAAM,UAAUA,kCAAiC;AACtD,MAAI,CAAC,UAAU;AACX,WAAO;AAAA,EACX;AACA,QAAM,aAAa,YAAY,QAAQ;AACvC,MAAI,eAAe;AACnB,QAAM,qBAAqB,WACtB,OAAO,CAAC,SAAS;AAElB,QAAI,KAAK,SAAS,aAAa,KAAK,KAAK,SAAS,iBAAiB,GAAG;AAClE,aAAO;AAAA,IACX;AACA,QAAI,eAAeA,oCAAmC,iBAAiB,IAAI,GAAG;AAC1E;AACA,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX,CAAC,EACI,KAAK,IAAI;AACd,SAAO;AACX;AACA,SAAS,iBAAiB,MAAM;AAC5B,SAAO,KAAK,WAAW,SAAS;AACpC;AACA,SAAS,YAAY,KAAK;AAEtB,SAAO,IAAI,MAAM,OAAO;AAC5B;;;ACrBA,OAAOC,SAAQ;AACf,IAAMC,gBAAe,gBAAgB,mBAAmB;AAAA,EACpD,eAAe,oBAAI,IAAI;AAAA;AAAA,EAEvB,OAAO,KAAK,SAAS;AACjB,QAAI,YAAY,QAAQ;AACpB,cAAQ,IAAI,GAAG;AAAA,IACnB,OACK;AACD,cAAQ,KAAK,GAAG;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,oBAAoB,oBAAI,QAAQ;AACpC,CAAC;AACD,wCAAwC;AACxC,IAAM,aAAa;AACnB,IAAM,wBAAwB,SAAS,YAAY,cAAc;AACjE,IAAM,kCAAkC;AACxC,SAAS,OAAO,WAAW,WAAW;AAjCtC;AAkCI,MAAI;AACA;AACJ,QAAM,YAAY,MAAM;AACpB,QAAI,CAAC,WAAW;AACZ,aAAO;AAAA,IACX;AACA,UAAM,sBAAsB,OAAO,cAAc,WAAW,YAAY,KAAK,UAAU,SAAS;AAChG,WAAOC,IAAG,IAAI,2DAA2D,mBAAmB,EAAE;AAAA,EAClG,GAAG;AACH,QAAM,OAAOA,IAAG,KAAK,2CAA2C;AAChE,MAAI,SAAS;AAAA,IACT,uCAAuC,IAAI;AAAA,IAC3C;AAAA,EACJ,EACK,OAAO,OAAO,EACd,KAAK,GAAG;AACb,WAAS,cAAc,MAAM;AAC7B,WAAS,oBAAoB,QAAQ,KAAK;AAC1C,WAAS,oBAAoB,QAAQ,IAAI;AACzC,QAAM,gBAAgB,+BAA+B,QAAQ,+BAA+B;AAC5F,QAAAD,cAAa,gBAAb,wBAAAA;AACA,QAAM;AACV;AACA,SAASE,aAAY,WAAW,QAAQ,EAAE,eAAe,IAAI,CAAC,GAAG;AAzDjE;AA0DI,MAAI;AACA;AACJ,mBAAiB,kBAAkBF,cAAa;AAChD,WAAS,cAAc,MAAM;AAC7B,WAAS,oBAAoB,QAAQ,aAAa;AAClD,WAAS,oBAAoB,MAAM;AACnC,QAAM,aAAa,+BAA+B,QAAQ,+BAA+B;AACzF,MAAI,gBAAgB;AAChB,IAAAA,cAAa,mBAAmB,IAAI,UAAU;AAAA,EAClD;AACA,QAAAA,cAAa,gBAAb,wBAAAA;AACA,QAAM;AACV;AAQA,SAASG,eAAc,WAAW,KAAK,EAAE,UAAU,eAAe,GAAG;AA9ErE;AA+EI,MAAI;AACA;AACJ,mBAAiB,kBAAkBC,cAAa;AAChD,QAAM,cAAc,GAAG;AACvB,QAAM,oBAAoB,KAAK,SAAS;AACxC,QAAM,oBAAoB,GAAG;AAC7B,MAAI,UAAU;AACV,UAAM,EAAE,cAAc,IAAIA;AAC1B,UAAM,MAAM,aAAa,OAAO,MAAM;AACtC,QAAI,cAAc,IAAI,GAAG,GAAG;AACxB;AAAA,IACJ,OACK;AACD,oBAAc,IAAI,GAAG;AAAA,IACzB;AAAA,EACJ;AACA,QAAAA,cAAa,gBAAb,wBAAAA;AACA,MAAI,gBAAgB;AAChB,UAAM,MAAM,+BAA+B,KAAK,+BAA+B;AAC/E,IAAAA,cAAa,mBAAmB,IAAI,GAAG;AACvC,IAAAA,cAAa,OAAO,KAAK,MAAM;AAAA,EACnC,OACK;AACD,IAAAA,cAAa,OAAO,KAAK,MAAM;AAAA,EACnC;AACJ;AAuBA,SAAS,oBAAoB,KAAK,KAAK;AACnC,MAAI,SAAS,IAAI,GAAG;AACpB,QAAM,QAAQ,QAAQ,YAAY,WAAW;AAC7C,WAASC,IAAG,KAAKA,IAAG,KAAK,EAAE,MAAM,CAAC;AAClC,SAAO,GAAG,MAAM,GAAG,GAAG;AAC1B;AACA,SAAS,cAAc,KAAK;AACxB,MAAI,IAAI,WAAW,GAAG,GAAG;AACrB,WAAO;AAAA,EACX,OACK;AACD,WAAO,IAAI,GAAG;AAAA,EAClB;AACJ;AACA,SAAS,oBAAoB,KAAK,qBAAqB,OAAO;AAC1D,QAAM,SAAS,qBAAqB,wBAAwB;AAC5D,SAAO,GAAG,MAAM,GAAG,GAAG;AAC1B;;;ACzIA,IAAMC,gBAAe,gBAAgB,wBAAwB;AAAA,EACzD,gBAAgB,oBAAI,QAAQ;AAAA,EAC5B,aAAa;AACjB,CAAC;;;ACVM,SAAS,YAAY;AAExB,SAAO,OAAO,WAAW,eAAe,OAAO,OAAO,YAAY;AAEtE;;;ACEA,OAAOC,SAAQ;AACf,IAAM,QAAQ,gBAAgB,6BAA6B,CAAC,CAAC;AAC7D,SAAS,sBAAsB;AAC3B,wBAAsB,qBAAqB,CAAC;AAC5C,QAAM,kBAAkB;AAC5B;AACA,SAAS,uBAAuB;AAC5B,SAAO,MAAM,oBAAoB;AACrC;AAKA,SAAS,sBAAsB,iBAAiB;AAE5C,EAAAC,aAAY,UAAU,GAAG,GAAGC,IAAG,KAAK,gDAAgD,CAAC,oCAAoC,EAAE,gBAAgB,KAAK,CAAC;AACjJ,EAAAC,eAAc,iBAAiB,+RAA+R,EAAE,gBAAgB,MAAM,UAAU,KAAK,CAAC;AAC1W;;;ACnBA,SAAS,aAAa,KAAK,aAAa;AACpC,MAAI,aAAa;AACb,WAAO,iBAAiB,KAAK,OAAO,0BAA0B,WAAW,CAAC;AAAA,EAC9E;AACJ;;;ACKA,OAAOC,SAAQ;AAyNf,SAAS,kBAAkB,KAAK;AAU5B,SAAO,wBAAwB,KAAK,GAAG;AAC3C;;;ACjPO,SAAS,UAAU,GAAG;AAAE;;;ACG/B,SAAS,YAAY,KAAK,aAAa,YAAY,CAAC,MAAM,GAAG;AACzD,SAAO,IAAI,SAAS,CAAC;AACrB,MAAI,IAAI,WAAW;AACf,WAAO,UAAU,IAAI,CAAC,CAAC;AAC3B,QAAM,SAAS,IAAI,MAAM,GAAG,IAAI,SAAS,CAAC;AAC1C,QAAM,OAAO,IAAI,IAAI,SAAS,CAAC;AAC/B,SAAO,OAAO,IAAI,SAAS,EAAE,KAAK,IAAI,IAAI,KAAK,WAAW,MAAM,UAAU,IAAI;AAClF;;;ACTA,OAAOC,SAAQ;AAEf,SAAS,eAAe,KAAK,QAAQ;AACjC,QAAM,aAAa,SAAS;AAC5B,SAAO,cAAc,CAAC;AACtB,MAAI,IAAI,SAAS,QAAQ;AACrB,WAAO;AAAA,EACX,OACK;AAGD,UAAM,IAAI,UAAU,GAAG,UAAU;AACjC,UAAM,WAAWC,IAAG,IAAI,KAAK;AAC7B,UAAM,MAAM;AACZ,WAAO;AAAA,EACX;AACJ;;;ACXA,IAAI,UAAU,GAAG;AACb,sBAAoB;AACxB;;;ACGA,OAAOC,SAAQ;AASf,SAAS,SAAS,KAAK,YAAY;AAC/B,QAAM,cAAc;AACpB,YAAU,KAAK,aAAa,IAAI;AAChC,QAAM,OAAO,CAAC,KAAK,UAAU,GAAG,CAAC;AACjC,MAAI,CAAC,YAAY;AACb,iBAAa;AAAA,EACjB,OACK;AACD,qBAAiB,YAAY,CAAC,KAAK,GAAG,GAAG,UAAU;AACnD,SAAK,KAAK,OAAO,UAAU,CAAC;AAAA,EAChC;AACA,QAAM,mBAAmB,CAAC;AAC1B,eAAa,kBAAkB;AAAA,IAC3B,cAAc;AAAA,IACd,YAAY,YAAY,KAAK,KAAK,IAAI,CAAC;AAAA,IACvC,cAAc;AAAA,MACV;AAAA,MACA;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO,YAAY,gBAAgB;AACvC;AACA,SAAS,OAAO,iBAAiB,aAAa;AAC1C,QAAM,OAAO,CAAC,OAAO,oBAAoB,WAAW,OAAO,eAAe,IAAI,KAAK,UAAU,eAAe,CAAC;AAC7G,MAAI,gBAAgB;AAChB,SAAK,KAAK,eAAe,KAAK,UAAU,WAAW,GAAG,EAAE,CAAC;AAC7D,QAAM,cAAc;AACpB,QAAM,YAAY,UAAU,KAAK,KAAK,IAAI,CAAC;AAC3C,SAAO,QAAQ,iBAAiB,aAAa,WAAW,WAAW;AACvE;AACA,SAAS,QAAQ,iBAAiB,aAAa,WAAW,aAAa,qBAAqB;AACxF,QAAM,mBAAmB;AAAA,IACrB;AAAA,IACA,cAAc;AAAA,IACd,YAAY;AAAA,EAChB;AACA,MAAI,qBAAqB;AACrB,WAAO,oBAAoB,6BAA6B,IAAI;AAC5D,iBAAa,kBAAkB,mBAAmB;AAAA,EACtD;AACA,MAAI,OAAO,oBAAoB,UAAU;AACrC,UAAM,MAAM;AACZ,cAAU,KAAK,WAAW;AAC1B,iBAAa,kBAAkB;AAAA,MAC3B,aAAa;AAAA,IACjB,CAAC;AACD,WAAO,YAAY,gBAAgB;AAAA,EACvC,OACK;AACD,UAAM,kBAAkB;AACxB,qBAAiB,iBAAiB,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,GAAG,QAAQ;AAC/E,iBAAa,kBAAkB;AAAA,MAC3B;AAAA,MACA,OAAO,oBAAoB;AAAA,IAC/B,CAAC;AACD,WAAO,YAAY,gBAAgB;AAAA,EACvC;AACJ;AACA,SAAS,YAAY,kBAAkB;AACnC,QAAM,MAAM,IAAI,MAAM,aAAa;AACnC,eAAa,KAAK,EAAE,mBAAmB,kBAAkB,CAAC,KAAK,GAAG,KAAK,CAAC;AACxE,YAAU,GAAG;AACb,SAAO;AACX;AAgBA,IAAM,QAAQ;AAkCd,SAAS,iBAAiB,YAAY,UAAU,QAAQ;AACpD,QAAM,kBAAkB,YAAY,SAAS,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,GAAG,IAAI;AAC3E,EAAAC,eAAc,SAAS,SAAS,UAAU,GAAG,2BAA2B,UAAU,cAAc,MAAM,oBAAoB,eAAe,wFAAwF,UAAU,sBAAsB,EAAE,UAAU,KAAK,CAAC;AACvR;AAkCA,SAAS,UAAU,KAAK,aAAa,kBAAkB;AACnD,EAAAC,aAAY,IAAI,WAAW,GAAG,KAAM,oBAAoB,kBAAkB,GAAG,GAAI;AAAA,IAC7E,eAAeC,IAAG,KAAK,GAAG,CAAC,cAAcA,IAAG,KAAK,WAAW,CAAC;AAAA,IAC7D,6BAA6BA,IAAG,KAAK,GAAG,CAAC;AAAA,IACzC,oBAAoB,wBAAwBA,IAAG,KAAK,QAAQ,CAAC,KAAKA,IAAG,KAAK,OAAO,CAAC;AAAA,EACtF,EACK,OAAO,OAAO,EACd,KAAK,GAAG,CAAC;AAClB;",
  "names": ["globalObject", "numberOfStackTraceLinesToRemove", "pc", "globalObject", "pc", "assertUsage", "assertWarning", "globalObject", "pc", "globalObject", "pc", "assertUsage", "pc", "assertWarning", "pc", "pc", "pc", "pc", "assertWarning", "assertUsage", "pc"]
}
